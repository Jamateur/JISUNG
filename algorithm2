#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define SWAP(x, y, temp) ( (temp)=(x), (x)=(y), (y)=(temp) )
// ��ȯ ���� �Լ�  
void Exchangesort(int n)
{
	int A[n];
	int i,j,temp;
	clock_t start, end;
	
	srand((unsigned int) time(NULL));
	
	for(i= 0; i < n; i++)
		A[i] = rand()%n;
	
	start = clock(); //����ð� ����  
	for(i = 0; i < n-1; i++)  //��ȯ���� �˰�����  
	{ 
		for(j = 0; j < n-i-1; j++)
		{
			if(A[j] > A[j + 1])
			{
				temp = A[j];
				A[j] = A[j + 1];
				A[j + 1] = temp;
			}
		}
	}
	end = clock(); // ����ð� ���� ����
	printf("%d�� ��ȯ���� �ð�: %lf�и���\n", n,(double)(end-start));
}
void merge(int list[], int left, int mid, int right){
  int i, j, k, l;
  i = left;
  j = mid+1;
  k = left;

  while(i<=mid && j<=right){
    if(list[i]<=list[j])
      sorted[k++] = list[i++];
    else
      sorted[k++] = list[j++];
  }

  if(i>mid){
    for(l=j; l<=right; l++)
      sorted[k++] = list[l];
  }
  else{
    for(l=i; l<=mid; l++)
      sorted[k++] = list[l];
  }

  for(l=left; l<=right; l++){
    list[l] = sorted[l];
  }
}

// �պ� ����
void merge_sort(int list[], int left, int right){
  int mid;

  if(left<right){
    mid = (left+right)/2 
    merge_sort(list, left, mid); 
    merge_sort(list, mid+1, right); 
    merge(list, left, mid, right); 
  }
} 
//������ ��Ƽ�� ������  
int partition(int list[], int left, int right)
{
	
  int pivot, temp;
  int low, high;

  low = left;
  high = right + 1;
  pivot = list[left]; 

  do
  {
    do 
	{
      low++;
    } 
	while (low<=right && list[low]<pivot);

    do 
	{
      high--; 
    } 
	while (high>=left && list[high]>pivot);

    if(low<high)
	{
      SWAP(list[low], list[high], temp);
    }
  } 
  while (low<high);

  SWAP(list[left], list[high], temp);

  return high;
}
// �� ���� �Լ�  
void quick_sort(int n, int left, int right)
{
  int A[n];
  int i;
  clock_t start, end;
  srand((unsigned int) time(NULL));
	
  for(i= 0; i < n; i++)
	A[i] = rand()%n;
  
  start = clock();
  if(left<right)
  {
    int q = partition(A, left, right); 

    quick_sort(A[n], left, q-1);
    quick_sort(A[n], q+1, right);
  }
  end = clock();
  printf("%d�� ������ �ð�: %lf�и���\n", n,(double)(end-start));

}
// �ִ� �� ���� �Լ�  
void insert_max_heap(HeapType *h, element item){
  int i;
  i = ++(h->heap_size); 

  while((i != 1) && (item.key > h->heap[i/2].key)){
    h->heap[i] = h->heap[i/2];
    i /= 2;
  }
  h->heap[i] = item; 
}
// �ִ� �� ���� �Լ�  
element delete_max_heap(HeapType *h){
  int parent, child;
  element item, temp;

  item = h->heap[1]; 
  temp = h->heap[(h->heap_size)--]; 
  parent = 1;
  child = 2;

  while(child <= h->heap_size){
    if( (child < h->heap_size) && ((h->heap[child].key) < h->heap[child+1].key) ){
      child++;
    }
    if( temp.key >= h->heap[child].key ){
      break;
    }

    h->heap[parent] = h->heap[child];
    parent = child;
    child *= 2;
  }

  h->heap[parent] = temp;
  return item;
}
//�� ���� �Լ�  
void heap_sort(element a[], int n){
  int i;
  HeapType h;

  init(&h);

  for(i=0; i<n; i++){
    insert_max_heap(&h, a[i]);
  }

  for(i=(n-1); i>=0; i--){
    a[i] = delete_max_heap(&h);
  }
}

// ���� �Լ�  
int main()
{
	Exchangesort(100);
	Exchangesort(500);
	Exchangesort(1000);
	Exchangesort(5000);
	Exchangesort(10000);
	
	return 0;
 } 
